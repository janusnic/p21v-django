# p21v-django

# Настройка базы данных

отредактируйте mysite/settings.py. 

По умолчанию используется SQLite. SQLite включен в Python, так что вам не нужно устанавливать что либо еще. Однако, при создании своего первого настоящего проекта, лучше использовать более функциональную базу данных, например PostgreSQL, чтобы избежать проблем со сменой базы данных в процессе разработки.

Если вы хотите использовать другую базу данных, установите необходимые библиотеки и измените настройки подключения к базе данных в DATABASES 'default':

- ENGINE – Доступные значения: 'django.db.backends.postgresql_psycopg2', 'django.db.backends.mysql', 'django.db.backends.sqlite3' или 'django.db.backends.oracle'. 

Также доступны другие бэкэнды.

- SAP SQL Anywhere - https://github.com/sqlanywhere/sqlany-django
- IBM DB2 - http://code.google.com/p/ibm-db/
- Microsoft SQL Server - http://django-mssql.readthedocs.org/en/latest/
- Firebird - https://github.com/maxirobaina/django-firebird
- ODBC - https://github.com/lionheart/django-pyodbc/
- ADSDB - http://code.google.com/p/adsdb-django/

- NAME – Название базы данных. Если вы используете SQLite, база данных будет файлом на вашем компьютере; в таком случае NAME должна содержать полный путь, включая название этого файла. Значение по умолчанию, os.path.join(BASE_DIR, 'db.sqlite3'), сохранит файл в каталоге проекта.

Если вы используете не SQLite, необходимо указать USER, PASSWORD, HOST. 

Если вы используете PostgreSQL или MySQL, убедитесь, что вы создали базу данных. Вы можете сделать это, выполнив запрос “CREATE DATABASE database_name;” в консоли базы данных.

Если вы используете SQLite, вам ничего не нужно создавать самостоятельно - файл базы данных будет создан автоматически при необходимости.
При редактировании mysite/settings.py, добавьте значение вашей временной зоны в TIME_ZONE.

Самый простой вариант настройки это одна SQLite база данных. Например:
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'mydatabase',
    }
}
```
При подключении к другим типам баз данных, таких как MySQL, Oracle или PostgreSQL, необходимы дополнительные параметры. 
Вот пример для PostgreSQL:
```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql_psycopg2',
        'NAME': 'mydatabase',
        'USER': 'mydatabaseuser',
        'PASSWORD': 'mypassword',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}
```
Следующие настройки могут быть использовать при подключении к различным базам данных:

# ATOMIC_REQUESTS
По умолчанию: False

Установите в True чтобы каждый HTTP запрос выполнялся в отдельной транзакции. 

# AUTOCOMMIT
По умолчанию: True

Укажите False, если хотите отключить управление транзакциями в Django и реализовать собственное.

# ENGINE
По умолчанию: '' (Пустая строка)

Бэкенд базы данных. Django предоставляет следующие бэкенды:

- 'django.db.backends.postgresql_psycopg2'
- 'django.db.backends.mysql'
- 'django.db.backends.sqlite3'
- 'django.db.backends.oracle'
- Вы можете использовать сторонние бэкэнды указав в ENGINE путь для импорта (например, mypackage.backends.whatever).


# HOST
По умолчанию: '' (Пустая строка)

Имя хоста используемого при подключении к базе данных. Пустая строка подразумевает localhost. Не используется для SQLite.

Если значение начинается с прямого слэша ('/') и используется MySQL, MySQL будет подключаться через Unix сокет к указанному сокету. Например:
```
"HOST": '/var/run/mysql'
```
Если вы используете MySQL и значение не начинается с прямого слэша, значение будет использоваться как имя хоста.

При использовании PostgreSQL, по умолчанию (при пустом HOST) подключение к базе данных будет выполнено через UNIX domain сокет (‘local’ в pg_hba.conf). Если у вас UNIX domain сокеты находятся не в стандартном каталоге, укажите в этой настройке значение unix_socket_directory из postgresql.conf. Если вы хотите использовать TCP сокеты, укажите в HOST ‘localhost’ или ‘127.0.0.1’ (‘host’ в pg_hba.conf). В Windows необходимо указать HOST, т.к. UNIX domain сокеты не доступны.

# NAME
По умолчанию: '' (Пустая строка)

Название используемой базы данных. Для SQLite – это полный путь к файлу базы данных. При указывании пути к файлу, всегда используйте обратные слэшы, даже на Windows (например, C:/homes/user/mysite/sqlite3.db).

# CONN_MAX_AGE
По умолчанию: 0

Время существования подключения к базе данных. При 0 подключение будет закрываться после каждого запроса — как это всегда работало в Django. При None подключение никогда не будет закрываться.

# OPTIONS
По умолчанию: {} (Пустой словарь)

Дополнительные параметры используемые при подключении к базе данных. Доступные параметры зависят от используемого бэкенда.

# PASSWORD
По умолчанию: '' (Пустая строка)

Пароль, используемый при подключении к базе данных. Не используется для SQLite.

# PORT
По умолчанию: '' (Пустая строка)

Порт, используемый при подключении к базе данных. Пустая строка подразумевает порт по умолчанию. Не используется для SQLite.

# USER
По умолчанию: '' (Пустая строка)

Имя пользователя используемое при подключении к базе данных. Не используется для SQLite.

# TEST

По умолчанию: {}

Словарь с настройками для тестовой базы данных. 

Можно использовать следующие настройки:

## CHARSET
По умолчанию: None

Кодировка(пер. character set encoding) используемая при создании тестовой базы данных. Значение передается непосредственно в базу данных, так что его формат зависит от используемой базы данных.

Поддерживается PostgreSQL (postgresql_psycopg2) и MySQL (mysql) бэкендами.

## COLLATION
По умолчанию: None

Порядок сортировки(пер. collation order), используемый при создании тестовой базы данных. Значение передается непосредственно в базу данных, так что его формат зависит от используемой базы данных.

Поддерживается только mysql.

## DEPENDENCIES
По умолчанию: ['default'] для всех используемых баз данных кроме default, которая не имеет зависимостей.

Порядок создания баз данных. 

## MIRROR
По умолчанию: None

Псевдоним базы данных, которую должна отображать конфигурируемая база данных при тестировании.

Эта настройка предназначена для тестирования master/slave конфигурации нескольких баз данных. 

## NAME
По умолчанию: None

Название базы данных используемой при тестировании.

Если указано значение по умолчанию (None) для SQLite, будет использована база данных в памяти. Для всех остальных баз данных будет использоваться 'test_' + DATABASE_NAME.


## SERIALIZE

Указывает сериализировать ли содержимое базы данных в JSON в памяти перед запуском тестов (используется для восстановления состояния базы данных между тестами, если не поддерживаются транзакции). Используется стандартным механизмом выполнения тестов Django. Вы можете указать False, чтобы ускорить выполнение тестов, если у вас нет тестов с serialized_rollback=True.

## CREATE_DB
По умолчанию: True

Эта настройка используется Oracle.

Если равно False, табличное пространство(tablespace) не будет создано на время выполнения тестов.

## CREATE_USER
По умолчанию: True

Эта настройка используется Oracle.

При False тестовый пользователь не будет создаваться на время выполнения тестов.

## USER
По умолчанию: None

Эта настройка используется Oracle.

Имя пользователя, которое будет использоваться Oracle при подключении к базе данных во время выполнения тестов. Если не указано, Django будет использовать 'test_' + USER.

## PASSWORD
По умолчанию: None

Эта настройка используется Oracle.

Пароль, который будет использоваться Oracle при подключении к базе данных во время выполнения тестов. Если значение не установлено Django будет использовать “захардкоденное” значение по умолчанию.

## TBLSPACE
По умолчанию: None

Эта настройка используется Oracle.

Название табличного пространства(tablespace), которое будет использоваться во время выполнения тестов. Если не указано, Django будет использовать 'test_' + USER.

## TBLSPACE_TMP
По умолчанию: None

Эта настройка используется Oracle.

Название временного табличного пространства(temporary tablespace), которое будет использоваться во время выполнения тестов. Если не указано, Django будет использовать 'test_' + USER + '_temp'.

## DATAFILE
По умолчанию: None

Эта настройка используется Oracle.

Название для файла с данными(datafile), который будет использоваться для TBLSPACE. Если не указан, Django будет использовать TBLSPACE + '.dbf'.

## DATAFILE_TMP

По умолчанию: None

Эта настройка используется Oracle.

Название для файла с данными(datafile), который будет использоваться для TBLSPACE_TMP. Если не указан, Django будет использовать TBLSPACE_TMP + '.dbf'.

## DATAFILE_MAXSIZE

По умолчанию: '500M'

Эта настройка используется Oracle.

Максимальный размер DATAFILE.

## DATAFILE_TMP_MAXSIZE

По умолчанию: '500M'

Эта настройка используется Oracle.

Максимальный размер DATAFILE_TMP.

# DATABASE_ROUTERS
По умолчанию: [] (Пустой список)

Список маршрутизаторов(routers), которые будут использоваться для определения какую базу данных использовать при выполнении запроса.


# DATE_FORMAT
По умолчанию: 'N j, Y' (например, Feb. 4, 2015)

Формат по умолчанию для отображение значений полей даты в любой части системы. Заметим, если USE_L10N равна True, будет использоваться формат даты текущей локали, если он указан в файлах локализации. 

# DATE_INPUT_FORMATS
По умолчанию:
```
(
    '%Y-%m-%d', '%m/%d/%Y', '%m/%d/%y', # '2006-10-25', '10/25/2006', '10/25/06'
    '%b %d %Y', '%b %d, %Y',            # 'Oct 25 2006', 'Oct 25, 2006'
    '%d %b %Y', '%d %b, %Y',            # '25 Oct 2006', '25 Oct, 2006'
    '%B %d %Y', '%B %d, %Y',            # 'October 25 2006', 'October 25, 2006'
    '%d %B %Y', '%d %B, %Y',            # '25 October 2006', '25 October, 2006'
)
```
Кортеж содержащий форматы даты, которые доступны в поле даты формы. Форматы проверяются в указанном порядке, используется первый подходящий. Заметим что эти строки используют формат datetime Python, а не формат шаблонного тега date.

При USE_L10N равном True, формат даты текущей локали имеет больший приоритет.

# DATETIME_FORMAT
По умолчанию: 'N j, Y, P' (например Feb. 4, 2003, 4 p.m.)

Формат по умолчанию для отображение значений полей даты и времени в любой части системы. Заметим, если USE_L10N равна True, будет использоваться формат даты текущей локали, если он указан в файлах локализации.

# DATETIME_INPUT_FORMATS
По умолчанию:
```
(
    '%Y-%m-%d %H:%M:%S',     # '2006-10-25 14:30:59'
    '%Y-%m-%d %H:%M:%S.%f',  # '2006-10-25 14:30:59.000200'
    '%Y-%m-%d %H:%M',        # '2006-10-25 14:30'
    '%Y-%m-%d',              # '2006-10-25'
    '%m/%d/%Y %H:%M:%S',     # '10/25/2006 14:30:59'
    '%m/%d/%Y %H:%M:%S.%f',  # '10/25/2006 14:30:59.000200'
    '%m/%d/%Y %H:%M',        # '10/25/2006 14:30'
    '%m/%d/%Y',              # '10/25/2006'
    '%m/%d/%y %H:%M:%S',     # '10/25/06 14:30:59'
    '%m/%d/%y %H:%M:%S.%f',  # '10/25/06 14:30:59.000200'
    '%m/%d/%y %H:%M',        # '10/25/06 14:30'
    '%m/%d/%y',              # '10/25/06'
)
```
Кортеж содержащий форматы даты, которые доступны в поле даты и времени формы. Форматы проверяются в указанном порядке, используется первый подходящий. эти строки используют формат datetime Python, а не формат шаблонного тега date.

При USE_L10N равном True, формат даты текущей локали имеет больший приоритет.

# DEBUG
По умолчанию: False

Включает/выключает режим отладки.

Никогда не включайте DEBUG на “боевом” сервере.

Одна из особенностей режима отладки – отображение подробной страницы с ошибкой. Если ваше приложение вызывает исключение при DEBUG равном True, Django покажет подробную отладочную информацию включая различные мета-данные об окружении, такие как настройки проекта (из settings.py).

В целях безопасности Django не включает небезопасные настройки, такие как SECRET_KEY. В том числе не отображаются настройки, которые содержат в названии следующее:
```
'API'
'KEY'
'PASS'
'SECRET'
'SIGNATURE'
'TOKEN'

```
Заметим, учитывается частичное совпадение. 'PASS' учитывает PASSWORD, также как и 'TOKEN' учитывает TOKENIZED и так далее.

Помните, что в любом случае страница с ошибкой будет содержать небезопасные данные при включенном режиме отладки. Пути к различным файлам, настройки и другая информация будет доступна для желающих атаковать ваш сайт.

Также при включенном DEBUG, Django запоминает каждый выполненный SQL запрос. Это полезно при отладке, но на сервере может занять много памяти.

Также при DEBUG равном False, необходимо правильно указать ALLOWED_HOSTS. Иначе все запросы будут возвращать “Bad Request (400)”.

# DEBUG_PROPAGATE_EXCEPTIONS
По умолчанию: False

При True стандартная обработка исключений в Django не будет использована и исключение будет “передано далее”. Это может быть полезным при разработке но не должно быть использовано на “боевом” сервере.

# DECIMAL_SEPARATOR
По умолчанию: '.' (Точка)

Десятичный разделитель, который используется при форматировании десятичных чисел.

Заметим, при USE_L10N равном True, будет использовано значение из настроек локали.


# DEFAULT_CHARSET
По умолчанию: 'utf-8'

Кодировка, которая используется по умолчанию для объектов HttpResponse если MIME-тип не указан явно. Используется вместе с DEFAULT_CONTENT_TYPE при установке заголовка Content-Type.

# DEFAULT_INDEX_TABLESPACE
По умолчанию: '' (Пустая строка)

Табличное пространство(tablespace) используемое для индексов полей, которые не указывают явно значение. Используется если база данных поддерживает их.

# DEFAULT_TABLESPACE
По умолчанию: '' (Пустая строка)

Табличное пространство(tablespace) используемое для моделей, которые не указывают явно значение. Используется если база данных поддерживает их.


# Модели
Модели отображают информацию о данных, с которыми вы работаете. Они содержат поля и поведение ваших данных. Обычно одна модель представляет одну таблицу в базе данных.

Каждая модель это класс унаследованный от django.db.models.Model.
```
from django.db import models
```
Атрибут модели представляет поле в базе данных.

```
class Category(models.Model):
    name = models.CharField('categories name', max_length=100)
    
    description = models.TextField(max_length=4096)
        
    views_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.name
```

name,description,views_count - поля модели. Каждое поле определено как атрибут класса (представлено экземпляром класса Field), и каждый атрибут соответствует полю таблицы в базе данных.

CharField для текстовых полей и DateTimeField для полей даты и времени. Это указывает Django какие типы данных хранят эти поля.

Названия каждого экземпляра Field - это название поля, в “машинном”(machine-friendly) формате. Вы будете использовать эти названия в коде, а база данных будет использовать их как названия колонок.

Вы можете использовать первый необязательный аргумент конструктора класса Field, чтобы определить отображаемое, удобное для восприятия, название поля. Оно используется в некоторых компонентах Django, и полезно для документирования. Если это название не указано, Django будет использовать “машинное” название. В этом примере, мы указали отображаемое название только для поля name - 'categories name'. Для всех других полей будет использоваться “машинное” название.

Некоторые классы, унаследованные от Field, имеют обязательные аргументы. Например, CharField требует, чтобы вы передали ему max_length. Это используется не только в схеме базы данных, но и при валидации.

Field может принимать различные необязательные аргументы; в нашем примере мы указали default значение для views_count равное 0.

## Активация моделей

- Создать структуру базы данных (CREATE TABLE) для приложения.

- Создать Python API для доступа к данным объектов Category.

Но первым делом мы должны указать нашему проекту, что приложение blog установлено.

Приложения Django “подключаемые”: вы можете использовать приложение в нескольких проектах и вы можете распространять приложение, так как они не связаны с конкретным проектом Django.

Отредактируйте файл mysite/settings.py и измените настройку INSTALLED_APPS добавив строку 'blog':

mysite/settings.py
```
# Application definition

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'todo',
    'blog',
)
```
Теперь Django знает, что необходимо использовать приложение blog. 

# INSTALLED_APPS
По умолчанию: () (Пустой кортеж)

Кортеж строк, который указывают все приложения Django, используемые в проекте. Каждая строка должна быть полным Python путем к:

- классу настройки приложения, или

- пакету с приложением.

INSTALLED_APPS теперь поддерживает конфигурации приложений.

Названия приложения и метки(labels) должны быть уникальны в INSTALLED_APPS
Названия приложений — Python путь к пакету приложения — должны быть уникальны. Нельзя подключить одно приложение дважды, разве что продублировав код с другим названием.

Короткие названия приложения — по умолчанию последняя часть названия приложения — должны быть так же уникальны. Например, можно использовать вместе django.contrib.auth и myproject.auth. Однако, необходимо указать label.

Эти правила распространяются на все приложения в INSTALLED_APPS, как на классы настройки приложений, так и на пакеты приложений.
Если несколько приложений содержат разные версии одних и тех же ресурсов (шаблоны, статические файлы, команды, файлы перевода), будут использоваться ресурсы из приложения, которое указано выше в INSTALLED_APPS.


# Поля

Самая важная часть модели – и единственная обязательная – это список полей таблицы базы данных которые она представляет. Поля определены атрибутами класса. Нельзя использовать имена конфликтующие с API моделей, такие как clean, save или delete.

```
class Category(models.Model):
    name = models.CharField(max_length=100)
    
    description = models.TextField(max_length=4096)
        
    views_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.name

class Tag(models.Model):
    name = models.CharField(max_length=100, unique=True)
    
    views_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.name

class Article(models.Model):
    title = models.CharField(max_length=100, unique=True)
        
    status = models.IntegerField(default=0)
    enable_comment = models.BooleanField(default=True)
    content = models.TextField()

    category = models.ForeignKey(Category)
    tags = models.ManyToManyField(Tag, blank=True)
        
    publish_date = models.DateTimeField(auto_now=True)

    created_date = models.DateTimeField(auto_now_add=True)
        
    views_count = models.IntegerField(default=0)
    comment_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.title
```

# Типы полей
Каждое поле в вашей модели должно быть экземпляром соответствующего Field класса. Django использует классы полей для определения такой информации:

- Типа колонки в базе данных (например: INTEGER, VARCHAR).

- Виджет используемый при создании поля формы (например: <input type="text">, <select>).

- Минимальные правила проверки данных, используемые в интерфейсе администратора и для автоматического создания формы.

В Django есть большое количество полей;

# Настройка полей
Для каждого поля есть набор предопределенных аргументов. Например, CharField (и унаследованные от него) имеют обязательный аргумент max_length, который определяет размер поля VARCHAR для хранения данных этого поля.

Также есть список стандартных аргументов для всех полей. Все они не обязательны.

# null
Если True, Django сохранит пустое значение как NULL в базе данных. По умолчанию - False.

# blank
Если True, поле не обязательно и может быть пустым. По умолчанию - False.

Это не то же что и null. null относится к базе данных, blank - к проверке данных. Если поле содержит blank=True, форма позволит передать пустое значение. При blank=False - поле обязательно.

# choices
Итератор (например, список или кортеж) 2-х элементных кортежей, определяющих варианты значений для поля. При определении, виджет формы использует select вместо стандартного текстового поля и ограничит значение поля указанными значениями.

Список значений выглядит:

```
ARTICLE_STATUS = (
    ('DRAFT', 'Not Reviewed'),
    ('PUBLISHED', 'Published'),
    ('EXPIRED', 'Expired'),
)


```
Первый элемент в кортеже - значение хранимое в базе данных, второй элемент - отображается виджетом формы, или в ModelChoiceField. Для получения отображаемого значения используется метод get_FOO_display экземпляра модели. Значения лучше указать в константах внутри модели:
```
from django.db import models

class Article(models.Model):
    ARTICLE_STATUS = (
        ('D', 'Not Reviewed'),
        ('P', 'Published'),
        ('E', 'Expired'),
    )


    name = models.CharField(max_length=60)
    status = models.CharField(max_length=1, choices=ARTICLE_STATUS)
    p = Article(name="Fred Flintstone", status="D")
    p.save()
    p.status

    p.get_status_display()

```

Значение по умолчанию для этого поля. Это может быть значение или функция. Если это функция - она будет вызвана при каждом создании объекта.

# help_text
Поля моделей в Django принимают атрибут help_text, который используется в Django формах/админке для вывода назначения полей  — это служит отличной возможностью для документации ваших моделей. Если в дальнейшем вы пригласите нового разработчика в проект, то help_text позволит сохранить бесчисленное количество часов на объяснения структуры моделей.

Подсказка, отображаемая в поле формы. 
при отображении в форме, HTML-символы не экранируются. Это позволяет использовать HTML в help_text если вам необходимо. Например:
```
help_text="Please use the following format: <em>YYYY-MM-DD</em>."
```
Также вы можете использовать обычный текст и django.utils.html.escape(), чтобы экранировать HTML. Убедитесь, что вы экранируете все подсказки, которые могут определять непроверенные пользователи, чтобы избежать XSS атак.

# primary_key

При True поле будет первичным ключом.

Если primary_key=True не указан ни для одного поля, Django самостоятельно добавит поле типа IntegerField для хранения первичного ключа, поэтому вам не обязательно указывать primary_key=True для каждой модели. 

Поле первичного ключа доступно только для чтения. Если вы поменяете значение первичного ключа для существующего объекта, а затем сохраните его, будет создан новый объект рядом с существующим. 
Например:
```
from django.db import models

class Fruit(models.Model):
    name = models.CharField(max_length=100, primary_key=True)
>>> fruit = Fruit.objects.create(name='Apple')
>>> fruit.name = 'Pear'
>>> fruit.save()
>>> Fruit.objects.values_list('name', flat=True)
['Apple', 'Pear']
unique
```
При True поле будет уникальным.

# краткое описание самых используемых аргументов.

## Первичный ключ по умолчанию
По умолчанию Django для каждой модели добавляет такое поле:
```
id = models.AutoField(primary_key=True)
```
Это автоинкрементный первичный ключ.

Для его переопределения просто укажите primary_key=True для одного из полей. При этом Django не добавит поле id.

Каждая модель должна иметь хотя бы одно поле с primary_key=True (явно указанное или созданное автоматически).

primary_key=True подразумевает null=False и unique=True. Модель может содержать только один первичный ключ.

# verbose_name
Field.verbose_name

## Читабельное имя поля
Каждое поле, кроме ForeignKey, ManyToManyField и OneToOneField, первым аргументом принимает необязательное читабельное название. Если оно не указано, Django самостоятельно создаст его, используя название поля, заменяя подчеркивание на пробел.
```
class Category(models.Model):
    name = models.CharField(max_length=100, verbose_name=_('name'))
    
    description = models.TextField(max_length=4096)
        
    views_count = models.IntegerField(default=0, verbose_name=_('views count'))
```

ForeignKey, ManyToManyField и OneToOneField первым аргументом принимает класс модели, поэтому используется keyword аргумент verbose_name:

```
class Article(models.Model):
    DRAFT = 'D'
    PUBLISHED = 'P'
    EXPIRED ='E'
    ARTICLE_STATUS = (
        (DRAFT, 'Not Reviewed'),
        (PUBLISHED, 'Published'),
        (EXPIRED, 'Expired'),
    )
    title = models.CharField(max_length=100, unique=True)
        
    status = models.CharField(max_length=1, choices=ARTICLE_STATUS, default=DRAFT)
    enable_comment = models.BooleanField(default=True)
    content = models.TextField()

    category = models.ForeignKey(Category, verbose_name="the related category")
    tags = models.ManyToManyField(Tag, blank=True)
        
    publish_date = models.DateTimeField(auto_now=True, help_text="Please use the following format: <em>YYYY-MM-DD</em>.")

```
Django не делает первую букву прописной для verbose_name - только там, где это необходимо.

# default
Field.default
Значение по умолчанию для поля. Это может быть значение или вызываемый(callable) объект. Если это вызываемый объект, он будет вызван при создании нового объекта.

Значение по умолчанию не может быть изменяемым значением (экземпляр модели, список, множество и т.д.), т.к. все объекты модели будут ссылаться на этот объект и использовать его как значение по умолчанию. Вместо этого укажите функцию, которая возвращает нужное значение. Например, если у вас есть собственное поле JSONField и вы хотите указать словарь как значение по умолчанию, используйте следующую функцию:
```
def contact_default():
    return {"email": "to1@example.com"}

contact_info = JSONField("ContactInfo", default=contact_default)
```
Обратите внимание, lambda нельзя использовать в качестве значения для default т.к. она не может быть сериализована для миграций.

Значение по умолчанию используется, если был создан экземпляр модели, а значение для поля не было указано. Если поле является первичным ключом, значение по умолчанию также использует и при указании None.


# unique
Field.unique
При True значение поля должно быть уникальным.

Этот параметр учитывается при сохранении в базу данных и при проверке данных в модели. Если вы попытаетесь сохранить повторное значение в поле с unique, будет вызвана ошибка django.db.IntegrityError методом save().

Этот параметр можно использовать для любого типа поля кроме ManyToManyField, OneToOneField и FileField.

Заметим что, при unique равном True, не нужно указывать db_index, т.к. unique создает индекс.


# Типы полей

## AutoField
class AutoField(**options)
Автоинкрементное поле IntegerField. Используется для хранения ID. Скорее всего вам не придется использовать это поле, первичный ключ будет автоматически добавлен к модели.

## BigIntegerField
class BigIntegerField([**options])
64-битное целочисленное, аналогично IntegerField но позволяет хранить числа от -9223372036854775808 до 9223372036854775807. Форма будет использовать TextInput для отображения.

## BooleanField
class BooleanField(**options)
Поле хранящее значение true/false.

Виджет по умолчанию для этого поля CheckboxInput.

Если вам нужен параметр null, используйте поле NullBooleanField.

по умолчанию для BooleanField None, если Field.default не указан.

## CharField
class CharField(max_length=None[, **options])
Строковое поле для хранения коротких или длинных строк.

Для большого количества текстовой информации используйте TextField.

Виджет по умолчанию для этого поля TextInput.

CharField принимает один дополнительный аргумент:

### CharField.max_length
Максимальная длинна(в символах) этого поля. max_length используется для проверки данных на уровне базы данных и форм Django.

Если вы создаете независимое приложение, которое должно работать на различных базах данных, помните что существуют некоторые ограничения использования max_length для некоторых типов баз данных. 
#### Пользователям MySQL
Если вы используете это поле с MySQLdb 1.2.2 и utf8_bin “collation” (которое не является значением по умолчанию), могут быть некоторые проблемы.

## DateField
class DateField([auto_now=False, auto_now_add=False, **options])
Дата, представленная в виде объекта datetime.date Python. Принимает несколько дополнительных параметров:

### DateField.auto_now
Значение поля будет автоматически установлено в текущую дату при каждом сохранении объекта. Полезно для хранения времени последнего изменения. текущее время будет использовано всегда; 

### DateField.auto_now_add
Значение поля будет автоматически установлено в текущую дату при создании(первом сохранении) объекта. Полезно для хранения времени создания. 

В форме поле будет представлено как :class:`~django.forms.TextInput с JavaScript календарем, и кнопкой “Сегодня”. Содержит дополнительную ошибку invalid_date.

Опции auto_now_add, auto_now и default взаимоисключающие. Использование их вместе вызовет ошибку.

При использовании auto_now или auto_now_add со значением True будут установлены параметры editable=False и blank=True.

Опции``auto_now`` и auto_now_add всегда используют дату в часовом поясе по умолчанию в момент создания или изменения объекта. Если такое поведение вам не подходит, вы можете указать свою функцию как значение по умолчанию, или переопределить метод save(), вместо использования auto_now или auto_now_add. Или использовать DateTimeField вместо DateField и выполнять преобразование в дату при выводе значения.

## DateTimeField
class DateTimeField([auto_now=False, auto_now_add=False, **options])
Дата и время, представленные объектом datetime.datetime Python. Принимает аналогичные параметры что и DateField.

Виджет по умолчанию в форме для этого поля - TextInput. Интерфейс администратора использует два виджета TextInput и JavaScript.

## IntegerField
class IntegerField([**options])
Число. Значение от -2147483648 до 2147483647 для всех поддерживаемых баз данных Django. Форма использует виджет TextInput.

## SlugField
class SlugField([max_length=50, **options])
Slug – газетный термин. “Slug” – это короткое название-метка, которое содержит только буквы, числа, подчеркивание или дефис. В основном используются в URL.

Как и для CharField, можно указать max_length. Если max_length не указан, Django будет использовать значение 50.

Устанавливает Field.db_index в True, если аргумент явно не указан.

Обычно значение SlugField создается на основе какого-то другого значения(например, название статьи). Это может работать автоматически в интерфейсе администрации благодаря параметру prepopulated_fields.


## SmallIntegerField
class SmallIntegerField([**options])
Как и поле IntegerField, но принимает значения в определенном диапазоне(зависит от типа базы данных). Для баз данных поддерживаемых Django можно использовать значения от -32768 до 32767.

## TextField
class TextField([**options])
Большое текстовое поле. Форма использует виджет Textarea.

Если указать атрибут max_length, это повлияет на поле, создаваемое виджетом Textarea. Но не учитывается на уровне модели или базы данных. Для этого используйте CharField.

#### Пользователям MySQL
Если вы используете это поле с MySQLdb 1.2.1p2 и utf8_bin “collation” (которое не является значением по умолчанию), могут быть некоторые проблемы. 

## TimeField¶
class TimeField([auto_now=False, auto_now_add=False, **options])
Время, представленное объектом datetime.time Python. Принимает те же аргументы, что и DateField.

Форма использует виджет TextInput. Интерфейс администратора также использует немного JavaScript.


# Миграции

Выполняя makemigrations, вы говорите Django, что внесли некоторые изменения в ваши модели и хотели бы сохранить их в миграции.

Миграции используются Django для сохранения изменений ваших моделей (и структуры базы данных) - это просто файлы на диске. Вы можете изучить миграцию для создания ваших моделей, она находится в файле blog/migrations/0001_initial.py. 

Команда sqlmigrate получает название миграции и возвращает SQL:

```
./manage.py sqlmigrate blog 0001
```
Вы увидите приблизительно такое:

```
BEGIN;
CREATE TABLE "blog_article" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "title" varchar(100) NOT NULL UNIQUE, 
    "status" varchar(1) NOT NULL, 
    "enable_comment" bool NOT NULL, 
    "content" text NOT NULL, 
    "publish_date" datetime NOT NULL, 
    "created_date" datetime NOT NULL, 
    "views_count" integer NOT NULL, 
    "comment_count" integer NOT NULL);

CREATE TABLE "blog_category" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "name" varchar(100) NOT NULL, 
    "description" text NOT NULL, 
    "views_count" integer NOT NULL);

CREATE TABLE "blog_tag" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "name" varchar(100) NOT NULL UNIQUE, 
    "views_count" integer NOT NULL);

CREATE TABLE "blog_article__new" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "title" varchar(100) NOT NULL UNIQUE, 
    "status" varchar(1) NOT NULL, 
    "enable_comment" bool NOT NULL, 
    "content" text NOT NULL, "publish_date" datetime NOT NULL, 
    "created_date" datetime NOT NULL, 
    "views_count" integer NOT NULL, 
    "comment_count" integer NOT NULL, 
    "category_id" integer NOT NULL REFERENCES "blog_category" ("id"));

INSERT INTO "blog_article__new" (
    "enable_comment", "comment_count", "title", "status", "content", "created_date", "id", "publish_date", "views_count", "category_id") SELECT "enable_comment", "comment_count", "title", "status", "content", "created_date", "id", "publish_date", "views_count", NULL FROM "blog_article";

DROP TABLE "blog_article";

ALTER TABLE "blog_article__new" RENAME TO "blog_article";

CREATE INDEX "blog_article_b583a629" ON "blog_article" ("category_id");

CREATE TABLE "blog_article_tags" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "article_id" integer NOT NULL REFERENCES "blog_article" ("id"), 
    "tag_id" integer NOT NULL REFERENCES "blog_tag" ("id"), 
    UNIQUE ("article_id", "tag_id"));

CREATE INDEX "blog_article_tags_a00c1b00" ON "blog_article_tags" ("article_id");
CREATE INDEX "blog_article_tags_76f094bc" ON "blog_article_tags" ("tag_id");

COMMIT;

```
Полученные запросы зависят от базы данных, которую вы используете. 

Названия таблиц созданы автоматически из названия приложения(blog) и названия модели в нижнем регистре – category, tag и article. (Вы можете переопределить это.)

Первичные ключи (ID) добавлены автоматически. (Вы можете переопределить и это.)

Django добавляет "_id" к названию внешнего ключа. (вы можете переопределить это.)

Учитываются особенности базы данных, которую вы используете. Специфические типы данных такие как auto_increment (MySQL), serial (PostgreSQL), или integer primary key (SQLite) будут использоваться автоматически. Тоже касается и экранирование названий, что позволяет использовать в названии кавычки – например, использование одинарных или двойных кавычек.

Команда sqlmigrate не применяет миграцию к базе данных - она просто выводит запросы на экран, чтобы вы могли увидеть какой SQL создает Django. Это полезно, если вы хотите проверить что выполнит Django, или чтобы предоставить вашему администратору базы данных SQL скрипт.

Если необходимо, можете выполнить python manage.py check. Эта команда ищет проблемы в вашем проекте не применяя миграции и не изменяя базу данных.

В Django есть команда, которая выполняет миграции и автоматически обновляет базу данных - она называется migrate. 

выполните команду migrate, чтобы создать таблицы для этих моделей в базе данных:

$ python manage.py migrate

Команда migrate выполняет все миграции, которые ещё не выполнялись, (Django следит за всеми миграциями, используя таблицу в базе данных django_migrations) и применяет изменения к базе данных, синхронизируя структуру базы данных со структурой ваших моделей.

Миграции - очень мощная штука. Они позволяют изменять ваши модели в процессе развития проекта без необходимости пересоздавать таблицы в базе данных. Их задача изменять базу данных без потери данных. 

1. Внесите изменения в модели (в models.py).

2. Выполните python manage.py makemigrations чтобы создать миграцию для ваших изменений

3. Выполните python manage.py migrate чтобы применить изменения к базе данных.

Две команды необходимы для того, чтобы хранить миграции в системе контроля версий. Они не только помогают вам, но и могут использоваться другими программистами вашего проекта.


Django предоставляет автоматически созданное API для доступа к данным; 


Заметим, что связь между моделями определяется с помощью ForeignKey.  Django поддерживает все основные типы связей: многие-к-одному, многие-ко-многим и один-к-одному.

# Поля отношений

Django предоставляет набор полей для определения связей между моделями.

## ForeignKey
class ForeignKey(othermodel[, **options])
Связь многое-к-одному. Принимает позиционный аргумент: класс связанной модели.

Для создания рекурсивной связи – объект со связью многое-к-одному на себя – используйте models.ForeignKey('self').

Если вам необходимо добавить связь на модель, которая еще не определена, вы можете использовать имя модели вместо класса:
```
from django.db import models

class Car(models.Model):
    manufacturer = models.ForeignKey('Manufacturer')
    # ...

class Manufacturer(models.Model):
    # ...
    pass
```
Для связи на модель из другого приложения используйте название модели и приложения. Например, если модель Manufacturer находится в приложении production, используйте:
```
class Car(models.Model):
    manufacturer = models.ForeignKey('production.Manufacturer')
```    
Такой способ позволяет создать циклическую зависимость между моделями из разных приложений.

В базе данных автоматом создается индекс для ForeignKey. Можно указать для db_index False, чтобы отключить такое поведение. Это может пригодиться, если внешний ключ используется для согласованности данных, а не объединения(join) в запросах, или вы хотите самостоятельно создать альтернативный индекс или индекс на несколько колонок.

Не рекомендуется использовать ForeignKey из приложения без миграций к приложению с миграциями. 
## Представление в базе данных
За кулисами, Django добавляет "_id" к названию поля для создания названия колонки. В примере выше, таблица для модели Car будет содержать колонку manufacturer_id. (Такое поведение можно изменить, указав аргумент db_column) Хотя, ваш код никогда не должен использовать названий колонок, если только вы не используете чистый SQL. Вы всегда будете использовать названия полей модели.

## Параметры
ForeignKey принимает дополнительные аргументы – все не обязательны – которые определяют, как должна работать связь.

### ForeignKey.limit_choices_to
Ограничивает доступные значения для поля при создании ModelForm или в админке (по умолчанию можно выбрать любой объект связанной модели). Можно передать словарь, объект Q или функцию, которая возвращает словарь или объект Q.
```
staff_member = models.ForeignKey(User, limit_choices_to={'is_staff': True})
```
указывает полю ModelForm показывать только объекты Users, которые соответствуют is_staff=True. Может быть полезно в админке.

Указание функции может быть полезно, если используется объект Python datetime для фильтрации. Например:
```
def limit_pub_date_choices():
    return {'pub_date__lte': datetime.date.utcnow()}

limit_choices_to = limit_pub_date_choices
```
Вместо словаря можете использовать объект Q или функцию, которая возвращает такой объект, для создания сложных запросов. Однако, если limit_choices_to объект Q, он будет использован в интерфейсе администратора, только если поле не находится в raw_id_fields класса ModelAdmin для этой модели.

Если используется функция для limit_choices_to, она будет вызываться при каждом создании формы. Также она может быть вызвана при валидации модели, например, командой или админкой. Админка может вызывать эту функцию несколько раз при проверке данных.

### ForeignKey.related_name
Название, используемое для обратной связи от связанной модели. Также значение по умолчанию для related_query_name (название обратной связи используемое при фильтрации результата запроса). 

Если вы не хотите, чтобы Django создавал обратную связь, установите related_name в '+' или добавьте в конце '+'. Например, такой код создаст связь, но не добавит обратную связь в модель User:
```
user = models.ForeignKey(User, related_name='+')
ForeignKey.related_query_name
```
Название обратной связи используемое при фильтрации результата запроса. По умолчанию используется related_name, или название модели:
```
# Declare the ForeignKey with related_query_name
class Tag(models.Model):
    article = models.ForeignKey(Article, related_name="tags", related_query_name="tag")
    name = models.CharField(max_length=255)

# That's now the name of the reverse filter
Article.objects.filter(tag__name="important")
```
## ForeignKey.to_field
Поле связанной модели, которое используется для создания связи между таблицами. По-умолчанию, Django использует первичный ключ.

## ForeignKey.db_constraint
Указывает создавать ли “constraint” для внешнего ключа в базе данных. По умолчанию True и в большинстве случает это то, что вам нужно. Указав False вы рискуете целостностью данных. Некоторые ситуации, когда вам может быть это необходимо:

- Вам досталась в наследство нецелостная база данных

- Вы используете шардинг базы данных.

При False, если связанный объект не существует, при обращении к нему будет вызвано исключение DoesNotExist.

## ForeignKey.on_delete
Когда объект, на который ссылается ForeignKey, удаляется, Django по-умолчанию повторяет поведение ограничения ON DELETE CASCADE в SQL и удаляет объекты, содержащие ForeignKey. Такое поведение может быть переопределено параметром on_delete. Например, если ваше поле ForeignKey может содержать NULL и вы хотите, чтобы оно устанавливалось в NULL после удаления связанного объекта:
```
user = models.ForeignKey(User, blank=True, null=True, on_delete=models.SET_NULL)
```
Возможные значения для on_delete находятся в django.db.models:

- CASCADE
Каскадное удаление, значение по умолчанию.

- PROTECT
Препятствует удалению связанного объекта вызывая исключение django.db.models.ProtectedError`(подкласс :exc:`django.db.IntegrityError).

- SET_NULL
Устанавливает ForeignKey в NULL; возможно только если null равен True.

- SET_DEFAULT
Устанавливает ForeignKey в значение по умолчанию; значение по-умолчанию должно быть указано для ForeignKey.

- SET()
Устанавливает ForeignKey в значение указанное в SET(). Если указан выполняемый объект, результат его выполнения. Вызываемый объект можно использовать, чтобы избежать запросов во время импорта models.py:
```
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models

def get_sentinel_user():
    return get_user_model().objects.get_or_create(username='deleted')[0]

class MyModel(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL,
                             on_delete=models.SET(get_sentinel_user))
```
- DO_NOTHING
Ничего не делать. Если используемый тип базы данных следит за целостностью связей, будет вызвано исключение IntegrityError, за исключением, когда вы самостоятельно добавите SQL правило ON DELETE для поля таблицы (возможно используя загрузочный sql).

## ForeignKey.swappable

Управляет поведением миграций, если ForeignKey ссылается на подменяемую(swappable) модель. При True - значение по умолчанию - если ForeignKey ссылается на модель, указанную через settings.AUTH_USER_MODEL (или другую настройку, определяющую какую модель использовать), связь в миграции будет использовать настройку, а не саму модель.

Вам может понадобится значение False только, если связь должна указывать на какую-то конкретную модель, игнорируя настройку - например, если это модель профиля пользователя для какой-то конкретной модели пользователя и не будет работать с любой моделью из настройки.

Указав False, вы не сможете ссылаться на подменяемую модель даже после того, как её подменили. False означает, что миграция, содержащая этот ForeignKey, будет указывать на конкретную модель, которую вы укажите (и пользователь вашего приложения получит ошибку, если попытается выполнить с моделью User, которую вы не поддерживаете).

Если вы не уверены какое значение выбрать, используйте значение по умолчанию True.

## ForeignKey.allow_unsaved_instance_assignment

Этот параметр добавлен для обратной совместимости т.к. в предыдущих версиях Django можно было назначать не сохраненные объекты.

Django не позволяет назначать полю ForeignKey не сохраненные объекты, чтобы избежать потерю данных (такие объекты просто игнорируются при сохранении объекта модели).

Если вам необходимо назначать не сохраненные объекты и вы не боитесь потенциальной потери данных (например, вы никогда не сохраняете объект в базу данных), вы можете отключить проверку, унаследовавшись от базового класса и указав True в allow_unsaved_instance_assignment. Например:
```
class UnsavedForeignKey(models.ForeignKey):
    # A ForeignKey which can point to an unsaved object
    allow_unsaved_instance_assignment = True

class Book(models.Model):
    author = UnsavedForeignKey(Author)
```
## ManyToManyField
class ManyToManyField(othermodel[, **options])

Связь многие-ко-многим. Принимает позиционный аргумент: класс связанной модели. Работает так же как и ForeignKey, включая рекурсивную и ленивую связь.

Связанные объекты могут быть добавлены, удалены или созданы с помощью RelatedManager.

Не рекомендуется использовать ManyToManyField из приложения без миграций к приложению с миграциями.
### Представление в базе данных
Django самостоятельно создаст промежуточную таблицу для хранения связи многое-ко-многим. По-умолчанию, название этой таблицы создается из названия поля и связанной модели. Так как некоторые базы данных не поддерживают длинные названия таблиц, оно будет обрезано до 64 символов и будет добавлен уникальный хеш. Это означает что вы можете увидеть такие названия таблиц author_books_9cdf4; это нормально. Вы можете указать название промежуточной таблицы, используя параметр db_table.

## Параметры
ManyToManyField принимает дополнительные аргументы – все не обязательны – которые определяют как должна работать связь.

- ManyToManyField.related_name
Аналогично ForeignKey.related_name.

- ManyToManyField.related_query_name
Аналогично ForeignKey.related_query_name.

- ManyToManyField.limit_choices_to
Аналогично ForeignKey.limit_choices_to.

- limit_choices_to``не работает для ``ManyToManyField переопределенной через through промежуточной моделью.

## ManyToManyField.symmetrical
Используется только при рекурсивной связи. Например, есть модель:
```
from django.db import models

class Person(models.Model):
    friends = models.ManyToManyField("self")
```
Загружая эту модель Django определяет, что она содержит ManyToManyField указывающее на себя, и не добавляет атрибут person_set классу модели Person. Вместо этого подразумевается, что :class:`ManyToManyField`симметрично – то есть, если я твой друг, то и ты мне друг.

Если вам не нужна симметричность для связи многое-ко-многим к self, установите symmetrical в False. Это заставит Django добавить дескриптор для обратной связи, позволяя ManyToManyField быть не симметричным.

## ManyToManyField.through
Django автоматически создает промежуточную таблицу для хранения связи. Однако, если вы хотите самостоятельно определить промежуточную таблицу, используйте параметр through указав модель Django, которая будет хранить связь между моделями.

Обычно используют для хранения дополнительных данных.

Если вы не указали through модель, вы все равно может обратиться к неявно промежуточной модели, которая была автоматически создана. Она содержит три поля, связывающие модели.

Если связанные модели разные, создаются следующие поля:
```
id: первичный ключ для связи.

<containing_model>_id: id модели, которая содержит поле ManyToManyField.

<other_model>_id: id модели, на которую ссылается ManyToManyField.
```
Если ManyToManyField ссылается на одну и ту же модель, будут созданы поля:
```
id: первичный ключ для связи.

from_<model>_id: id объекта основной модели (исходный объект).

to_<model>_id: id объекта, на который указывает связь (целевой объект).
```
Этот класс может использоваться для получения связей.

## ManyToManyField.through_fields

Используется, если явно указана промежуточная модель для связи многое-ко-многим. Обычно Django самостоятельно определяется какие поля использовать для создания связи. 
```
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=50)

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through='Membership', through_fields=('group', 'person'))

class Membership(models.Model):
    group = models.ForeignKey(Group)
    person = models.ForeignKey(Person)
    inviter = models.ForeignKey(Person, related_name="membership_invites")
    invite_reason = models.CharField(max_length=64)
```
Membership содержит два внешних ключа на Person (person и inviter). В таком случае Django не знает какой ключ использовать для создания связи. В таком случае необходимо явно указать Django, какой внешний ключ правильный, используя параметр through_fields, как в примере выше.

- through_fields принимает двух-элементный кортеж ('field1', 'field2'), где field1 – название внешнего ключа, который ссылается на модель, которая содержит ManyToManyField (в нашем примере group), а field2 – внешний ключ, который ссылается на целевую модель (в нашем примере person).

Если промежуточная модель содержит несколько внешний ключей на одну из моделей связи (или обе модели), вы должны указать through_fields. Это также относится и к рекурсивной связи, если используется своя промежуточная модель, в которой больше двух связей на модель, или вы хотите явно указать Django, какие внешние ключи использовать.

Рекурсивные связи, использующие промежуточную модель, всегда считаются несимметричными – то есть с symmetrical=False – поэтому существуют понятия “источник” и “цель” связи. В этом случае 'field1' будет “источником” связи, а 'field2' – “целью”.

## ManyToManyField.db_table
Имя промежуточной таблицы для хранения связей многое-ко-многим. Если не указан, Django самостоятельно создаст название по умолчанию используя название таблицы определяющей связь и название поля.

## ManyToManyField.db_constraint
Указывает создавать ли “constraint” для внешних ключей в промежуточной таблице в базе данных. По умолчанию True и в большинстве случает это то, что вам нужно. Указав False вы рискуете целостностью данных. Некоторые ситуации, когда вам может быть это необходимо:

- Вам досталась в наследство нецелостная база данных

- Вы используете шардинг базы данных.

Нельзя указать db_constraint и through одновременно.

## ManyToManyField.swappable

Управляет поведением миграций, если ManyToManyField ссылается на подменяемую(swappable) модель. При True - значение по умолчанию - если ManyToManyField ссылается на модель, указанную через settings.AUTH_USER_MODEL (или другую настройку, определяющую какую модель использовать), связь в миграции будет использовать настройку, а не саму модель.

Вам может понадобится значение False только, если связь должна указывать на какую-то конкретную модель, игнорируя настройку - например, если это модель профиля пользователя для какой-то конкретной модели пользователя и не будет работать с любой моделью из настройки.

Если вы не уверены какое значение выбрать, используйте значение по умолчанию True.

## ManyToManyField.allow_unsaved_instance_assignment

Работает аналогично ForeignKey.allow_unsaved_instance_assignment.

ManyToManyField не поддерживает validators.

null не влияет на работу поля т.к. нет способа сделать связь обязательной на уровне базы данных.

# OneToOneField
class OneToOneField(othermodel[, parent_link=False, **options])
Связь один-к-одному. Работает так же, как и ForeignKey с unique=True, но “обратная” связь возвращает один объект.

В основном применяется как первичный ключ модели, которая “расширяет” другую модель. Например, Multi-table наследование работает через неявное добавление связи один-к-одному от дочерней модели к родительской.

Принимает обязательный позиционный аргумент: класс связанной модели. Работает так же как и ForeignKey, включая рекурсивную и “ленивую” связь.

Если вы не указали related_name для OneToOneField, Django будет использовать название модели в нижнем регистре.

```

from django.conf import settings
from django.db import models

class MySpecialUser(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL)
    supervisor = models.OneToOneField(settings.AUTH_USER_MODEL, related_name='supervisor_of')
```
модель User будет содержать следующие атрибуты:
```
>>> user = User.objects.get(pk=1)
>>> hasattr(user, 'myspecialuser')
True
>>> hasattr(user, 'supervisor_of')
True
```
При получении связанного объекта через обратную связь, если такой объект не существует, будет вызвано исключение DoesNotExist. Например, если пользователь не имеет соответствующего экземпляра в MySpecialUser:
```
>>> user.supervisor_of
Traceback (most recent call last):
    ...
DoesNotExist: User matching query does not exist.
```
Также OneToOneField принимает все дополнительные параметры принимаемые ForeignKey, и еще один дополнительный:

### OneToOneField.parent_link
При True и связанной модели, которая наследуется от другой модели, определяет, что должна сохраняться связь на родительскую модель, а не поле OneToOneField дочерней модели, которое используется для организации наследования моделей.

# Admin
Запускаем сервер для разработки
```
./manage.py runserver
Performing system checks...

System check identified no issues (0 silenced).
October 27, 2015 - 12:51:22
Django version 1.8.5, using settings 'mysite.settings'
Starting development server at http://127.0.0.1:8000/
Quit the server with CONTROL-C.
[27/Oct/2015 12:51:35] "GET / HTTP/1.1" 200 507
```
Интерфейс администратора включен по умолчанию. 

Откроем “/admin/” локального домена в браузере – например, http://127.0.0.1:8000/admin/. Вы должны увидеть страницу авторизации интерфейса администратора
```
27.0.0.1:8000/admin/
```

Т.к. translation включен по умолчанию, страница авторизации может быть на вашем родном языке, зависит от настроек браузера и наличия перевода для вашего языка.

# Заходим в интерфейс администратора¶

Вы должны увидеть несколько разделов: группы и пользователи. Они предоставлены приложением авторизации Django django.contrib.auth.

## Добавим приложение blog в интерфейс администратора

blog/admin.py
```
from django.contrib import admin

from .models import Category

admin.site.register(Category)
```

Поля формы формируются на основе описания модели Category.

```
class Category(models.Model):
    name = models.CharField(max_length=100, verbose_name='name')
    
    description = models.TextField(max_length=4096)
        
    views_count = models.IntegerField(default=0, verbose_name='views count')

    def __unicode__(self):
        return self.name

```
Для различных типов полей модели (TextField, CharField, IntegerField) используются соответствующие HTML поля. Каждое поле знает как отобразить себя в интерфейсе администратора.

В нижней части страницы мы видим несколько кнопок:

- Save – сохранить изменения и вернуться на страницу списка объектов.

- Save and continue editing – сохранить изменения и снова загрузить страницу редактирования текущего объекта.

- Save and add another – Сохранить изменения и перейти на страницу создания нового объекта.

- Delete – Показывает страницу подтверждения удаления.

```
from django.contrib import admin

# Register your models here.
from .models import Category, Tag, Article

admin.site.register(Category)
admin.site.register(Tag)
admin.site.register(Article)
```

При использовании auto_now или auto_now_add со значением True будут установлены параметры editable=False и blank=True.

```
class Article(models.Model):
    DRAFT = 'D'
    PUBLISHED = 'P'
    EXPIRED ='E'
    ARTICLE_STATUS = (
        (DRAFT, 'Not Reviewed'),
        (PUBLISHED, 'Published'),
        (EXPIRED, 'Expired'),
    )
    title = models.CharField(max_length=100, unique=True)
        
    status = models.CharField(max_length=1, choices=ARTICLE_STATUS, default=DRAFT)
    enable_comment = models.BooleanField(default=True)
    content = models.TextField()

    category = models.ForeignKey(Category, verbose_name="the related category")
    tags = models.ManyToManyField(Tag, verbose_name="the related tags", blank=True)
        
    publish_date = models.DateTimeField(auto_now=False, help_text="Please use the following format: <em>YYYY-MM-DD</em>.")

    created_date = models.DateTimeField(auto_now_add=False)
        
    views_count = models.IntegerField(default=0)
    comment_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.title
```

К полям DateTimeField добавлен JavaScript виджет. Для даты добавлена кнопка “Сегодня” и календарь, для времени добавлена кнопка “Сейчас” и список распространенных значений.

Если значение “Publish date” не совпадает с временем создания объекта, возможно, вы неверно определили настройку TIME_ZONE. Измените ее и перезагрузите страницу.

Измените “Publish date”, нажав “Today” и “Now”. Затем нажмите “Save and continue editing.” Теперь нажмите “History” в правом верхнем углу страницы. Вы увидите все изменения объекта, сделанные через интерфейс администратора, время изменений и пользователя, который их сделал:

Please use the following format: YYYY-MM-DD.
```
publish_date = models.DateTimeField(auto_now=False, help_text="Please use the following format: <em>YYYY-MM-DD</em>.")
```

## Настройка формы

После регистрации модели Article, используя admin.site.register(Article), Django создал форму для модели. Скорее всего, вам захочется изменить ее. Вы можете это сделать, используя параметры при регистрации модели.

Давайте поменяем порядок полей в форме. 
```
'title','status','enable_comment','content','category','tags','publish_date','created_date','views_count','comment_count'
```
Замените admin.site.register(Article) на:

blog/admin.py
```
from django.contrib import admin

from .models import Article

class ArticleAdmin(admin.ModelAdmin):
    fields = ['title','category','content','created_date','publish_date','tags','status','enable_comment','views_count','comment_count']

admin.site.register(Article, ArticleAdmin)
```
Создаем объект ModelAdmin и предаем его в admin.site.register().

Теперь поле “Publication date” отображается перед полем “Tag”:

Для форм с большим количеством полей можно разбить форму на группу полей:

blog/admin.py
```
from django.contrib import admin

from .models import Article

class ArticleAdmin(admin.ModelAdmin):
    fieldsets = [
        ('Item',             {'fields': ['title','category','content']}),
        ('Date information', {'fields': ['created_date','publish_date']}),
        ('Related tags',     {'fields': ['tags']}),
        ('Metas',            {'fields': ['status','views_count']}),
        ('Comments',            {'fields': ['enable_comment','comment_count']}),
    ]

admin.site.register(Article, ArticleAdmin)
```
Первый элемент кортежа в fieldsets – название группы полей.

Вы можете добавить HTML классы для каждой группы полей. Django предоставляет класс "collapse", который отображает группу полей изначально скрытой. Это полезно, если форма содержит поля, которые редко редактируются:

blog/admin.py
```

from django.contrib import admin

from .models import Article

class ArticleAdmin(admin.ModelAdmin):
    fieldsets = [
        ('Item',             {'fields': ['title','category','content']}),
        ('Date information', {'fields': ['created_date','publish_date'], 'classes': ['collapse']}),
        ('Related tags',     {'fields': ['tags']}),
        ('Metas',            {'fields': ['status','views_count']}),
        ('Comments',         {'fields': ['enable_comment','comment_count'], 'classes': ['collapse']}),
    ]

admin.site.register(Article, ArticleAdmin)

```

# Добавление связанных объектов

```
from .models import Category, Tag, Article

admin.site.register(Category)
admin.site.register(Tag)
```

Django знает, что поле ForeignKey должно быть представлено как select. 

Обратите внимание на ссылку “Add Another category” возле поля Category. При нажатии на “Add Another category” будет показано всплывающее окно с формой добавления category. 


# __str__ или __unicode__

“Волшебный метод” Python, который возвращает unicode “представление” объекта. Это то, что Python и Django используют для отображения объекта как строки, обычно в консоли, интерфейсе администратора или шаблоне.

Желательно определить этот метод, т.к. значение по умолчанию не слишком привлекательно.
```
class Tag(models.Model):
    name = models.CharField(max_length=100, unique=True)
    
    views_count = models.IntegerField(default=0)

    def __unicode__(self):
        return self.name

```

В Python 3 просто используйте __str__().

В Python 2 необходимо определить метод __unicode__(), который возвращает unicode. Модели Django содержат метод __str__(), который вызывает метод __unicode__() и конвертирует результат в UTF-8 байтовую строку. Это означает, что unicode(p) вернет строку Unicode, и str(p) вернет обычную строку, символы которой закодированы в UTF-8. Python делает наоброт: object содержит метод __unicode__, который вызывает __str__ и конвертирует результат ASCII байтовую строку. Это отличие может вводить в заблуждение.



# Настройка страницы списка объектов

По умолчанию Django отображает результат выполнения str() для каждого объекта. Но чаще всего хочется показывать список полей. Для этого используйте параметр list_display, который является кортежем состоящим из названий полей модели:

blog/admin.py
```
class ArticleAdmin(admin.ModelAdmin):

    # ...
    list_display = ('title', 'publish_date', 'status')
```
Для примера давайте еще и добавим метод was_published_recently:

blog/admin.py
```
class ArticleAdmin(admin.ModelAdmin):
    # ...
    list_display = ('title', 'publish_date', 'status', 'was_published_recently')
```

Вы можете нажать на заголовок колонки чтобы отсортировать записи по полю – но не для was_published_recently, так как сортировка по методу не поддерживается. Название колонки для was_published_recently по умолчанию равно названию метода (нижние подчеркивание заменяется на пробелы), а значение равно строковому представлению результата выполнения метода.

Вы можете исправить это, добавив несколько атрибутов (в blog/models.py) этому методу:

blog/models.py
```
from django.db import models
import datetime
from django.utils import timezone

class Article(models.Model):
    # ...
    def was_published_recently(self):
        return self.publish_date >= timezone.now() - datetime.timedelta(days=1)
    was_published_recently.admin_order_field = 'publish_date'
    was_published_recently.boolean = True
    was_published_recently.short_description = 'Published recently?'
```

Отредактируем файл blog/admin.py снова и добавим на страницу списка вопросов Фильтры, используя list_filter. 
```
list_filter = ['publish_date']
```
Это добавляет “Фильтр” по полю publish_date в боковой панели:

Тип фильтра зависит от типа поля. Так как publish_date является DateTimeField, Django отображает соответствующие варианты для фильтрации: “Any date,” “Today,” “Past 7 days,” “This month,” “This year.”

# Теперь добавим поиск:
```
search_fields = ['title']
```
Это добавляет поле для поиска в верхней части страницы. При вводе запроса, Django будет искать по полю title. Вы можете использовать любое количество полей – учтите что используется запрос LIKE, так что постарайтесь не перегрузить вашу базу данных.

Страница списка объектов также содержит постраничное отображение. По умолчанию отображается 100 объектов на страницу. Поменять количество объектов на одной странице, поля для поиска, фильтры, добавить иерархию по дате и отображаемые поля - все это возможно.

# Настраиваем внешний вид

“Django administration” в “шапке” страницы выглядит нелепо. Это просто замещающий текст.

Его очень легко заменить, используя систему шаблонов Django. Интерфейс администратора работает благодаря Django и использует систему шаблонов Django.

# Переопределение шаблонов проекта
Создайте каталог templates в каталоге проекта (который содержит manage.py). Шаблоны могут располагаться где угодно, главное чтобы Django имел доступ к ним. (Django запускается под пользователем, под которым запущен сервер.) Но мы советуем располагать шаблоны внутри проекта.

Откройте файл настроек (напомним это mysite/settings.py) и найдите опцию DIRS в настройке TEMPLATES:
```
mysite/settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
```
DIRS – это список путей к каталогам, который указывает, где Django будет искать шаблоны.

Теперь создайте каталог admin в каталоге templates, и скопируйте шаблон admin/base_site.html из встроенных шаблонов в исходниках Django (django/contrib/admin/templates) в этот каталог.

# Где лежит исходный код Django?
Если вы не знаете где лежат исходники Django, выполните следующую команду:
```
$ python -c "
import sys
sys.path = sys.path[1:]
import django
print(django.__path__)"
```
Затем просто отредактируйте файл и замените {{ site_header|default:_('Django administration') }} (включая фигурные скобки) на название вашего сайта. Должно получиться наподобие:
```
{% extends "admin/base.html" %}

{% block title %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

{% block branding %}
<h1 id="site-name"><a href="{% url 'admin:index' %}">Janus Blog Administration</a></h1>

{% endblock %}

{% block nav-global %}{% endblock %}

```
При разработке проекта для этого обычно используют атрибут django.contrib.admin.AdminSite.site_header.

Этот шаблон содержит текст подобный {% block branding %} и {{ title }}. Теги {% и {{ – это части синтаксиса системы шаблонов Django. При выполнении шаблона admin/base_site.html Django создаст HTML страницу. 

Любой шаблон интерфейса администратора можно переопределить. Чтобы переопределить шаблон, сделайте тоже что и с base_site.html – скопируйте его в каталог с шаблонами проекта и внесите изменения.

# Настройка шаблонов приложения
Т.к. APP_DIRS по умолчанию True, Django пытается найти шаблон в подкаталоге templates/ каждого приложении, если шаблон не найден другим способом.


# Настроим главную страницу

Возможно, вам понадобится настроить главную страницу интерфейса администратора.

По умолчанию она показывает все приложения в алфавитном порядке из настройки INSTALLED_APPS, которые зарегистрированы в интерфейсе администратора. Главная страница очень важна и должна быть удобной.

Для главной страницы используется шаблон admin/index.html. (Сделайте тоже что и с шаблоном admin/base_site.html – скопируйте его из приложения Django в каталог шаблонов проекта.) Откройте файл и вы увидите использование переменной app_list. Эта переменная содержит все отображаемые приложения. Вместо нее вы можете явно указать ссылки на нужные страницы.

```
{% extends "admin/base_site.html" %}
{% load i18n admin_static %}

{% block extrastyle %}{{ block.super }}<link rel="stylesheet" type="text/css" href="{% static "admin/css/dashboard.css" %}" />{% endblock %}

{% block coltype %}colMS{% endblock %}

{% block bodyclass %}{{ block.super }} dashboard{% endblock %}

{% block breadcrumbs %}{% endblock %}

{% block content %}
<div id="content-main">

{% if app_list %}
    {% for app in app_list %}
        <div class="app-{{ app.app_label }} module">
        <table>
        <caption>
            <a href="{{ app.app_url }}" class="section" title="{% blocktrans with name=app.name %}Models in the {{ name }} application{% endblocktrans %}">{{ app.name }}</a>
        </caption>
        {% for model in app.models %}
            <tr class="model-{{ model.object_name|lower }}">
            {% if model.admin_url %}
                <th scope="row"><a href="{{ model.admin_url }}">{{ model.name }}</a></th>
            {% else %}
                <th scope="row">{{ model.name }}</th>
            {% endif %}

            {% if model.add_url %}
                <td><a href="{{ model.add_url }}" class="addlink">{% trans 'Add' %}</a></td>
            {% else %}
                <td>&nbsp;</td>
            {% endif %}

            {% if model.admin_url %}
                <td><a href="{{ model.admin_url }}" class="changelink">{% trans 'Change' %}</a></td>
            {% else %}
                <td>&nbsp;</td>
            {% endif %}
            </tr>
        {% endfor %}
        </table>
        </div>
    {% endfor %}
{% else %}
    <p>{% trans "You don't have permission to edit anything." %}</p>
{% endif %}
</div>
{% endblock %}

{% block sidebar %}
<div id="content-related">
    <div class="module" id="recent-actions-module">
        <h2>{% trans 'Recent Actions' %}</h2>
        <h3>{% trans 'My Actions' %}</h3>
            {% load log %}
            {% get_admin_log 10 as admin_log for_user user %}
            {% if not admin_log %}
            <p>{% trans 'None available' %}</p>
            {% else %}
            <ul class="actionlist">
            {% for entry in admin_log %}
            <li class="{% if entry.is_addition %}addlink{% endif %}{% if entry.is_change %}changelink{% endif %}{% if entry.is_deletion %}deletelink{% endif %}">
                {% if entry.is_deletion or not entry.get_admin_url %}
                    {{ entry.object_repr }}
                {% else %}
                    <a href="{{ entry.get_admin_url }}">{{ entry.object_repr }}</a>
                {% endif %}
                <br/>
                {% if entry.content_type %}
                    <span class="mini quiet">{% filter capfirst %}{{ entry.content_type }}{% endfilter %}</span>
                {% else %}
                    <span class="mini quiet">{% trans 'Unknown content' %}</span>
                {% endif %}
            </li>
            {% endfor %}
            </ul>
            {% endif %}
    </div>
</div>
{% endblock %}

```